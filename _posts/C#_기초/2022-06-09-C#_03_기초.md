---
layout: post
title : "[C#] 03. 3장정리/메모리기본 heap stack/형변환, 열거, 문자열다루기"
subheading: 개인정리용 글입니다. 틀린부분있을수도 있음.
author: Donghui Lee
categories: 이것이_C#이다

banner:
    image: /assets/images/banners/computer.jpg
    subheading_style: "color: gold"
tag: [C#, 이것이 C#이다 ]

---
## 1. 변수
```c#
int x = 100; // -> 초기화를 한것임 / 최초의 데이터를 메로리에 할당한것 / 아무거도 안쓰면 더미데이터가 들어가는데 이를 방지하기위해 c#에서는 강제로 초기화를 함.
```

## 2. 메모리에 대한 이야기
c#으로 작성한 프로그램은 두가지 메모리 영역을 사용한다.  
바로 stack과 heap이다.  
참조형식의 데이터는 heap과 관련이 있다.  
~~~
{
    int a = 100;
    int b = 200;
    int c = 300;
} 이라고 치면
stack 영역에서는 차곡차곡 쌓였다가 역순으로 다시 빠져나간다
300밑에 }를 만난순간 젤위의 데이터인 300부터 빠져나간다.

=> 스텍은 청소부 같으며 자동으로 쓰레기데이터가 없도록 다 수거해간다

힙같은 경우는 스스로 데이터를 제거하는 메커니즘이 없다 그래서 청소부를 따로 고용하고있다. 바로 CLR의 가비지 컬렉션이다. 얘가 프로그램뒤에서 숨어서 동작하면 사용하지 않는 객체를 다 제거한다.

=> 여기서 의문점 왜 청소부가 있는 스택에 다 데이터를 넣지않는냐?
그 이유는 }로 끝나는 순간 데이터가 다 사라지고 유지를 할수없기 때문이다.
프로그래머가 heap에 데이터를 올려두면 프로그래머가 더이상 사용하지 않을때까지 있다가 가비지 커렉션이 알아서 없에줌

{
    object a = 10;
    object b = 20;
}
이것을 실행하면 CLR은 실제값 10,20은 힙에 저장하고 이 힙의 메모리주소를 스택에 저장한다.

~~~

## 3. object 형식에 대해 알아보자
여러 값형식이나 참조형식은 이미 아니까 object에 대해서만 잠시 알아보자  
object는 모든 형식을 담을수 있으며 이를 위해 C#에서는 모든 데이터형식을 object로 부터 상속되게 하였다. 심지어 프로그래머들이 만드는 참조형식도 눈에는 안보이지만 Object를 자동으로 상속되게 하엿다. 이로써 결국에는 모든 데이터형식은 object와 연결되었다.  
<br>
결국 object는 참조형인데 int나 double같은 값형식들이다. object에 값형식들을 넣기 위해 박싱이라는 기능을 제공한다. => 책 68페이지 참고

## 4. 형변환

## 5. 열거형식에 대해서 한번 정리할것

## 6. Nullable

C# 컴파일러는 변수가 선언되면 어떤값이든 넣도록 강제한다.
하지만 코딩을 하다 보면 어떤 값도 가지지 않는 변수가 필요할때가있다.
// 해보니까 선언자체만 했을때 문법적으로도 오류가 없고 실행했을때도 이상없음 하지만 그 선언만 한 변수를 출력한다고 쓰면 바로 오류로 체크됨


바로 Nullable 형식  
ex) 
~~~c#
int? a = null;
float? b = null;
double? c = null;
~~~
속성은 2가지가 있다
ex) a = 29;  
    a.HasValue => 값이 있는지 없는지 =>  True냐 False냐
    a.Value => 값 출력 / 근데 해보니까 그냥 a만적어도 출력되긴함

## 7. var에 대해 알아보자
C# 컴파일러는 강한 형식검사를 한다. 그래서 코드작성할때는 귀찮을수있다. var을 이용하면 약한 형식 검사를 한다.  
var는 자동으로 해당 변수의 형식을 정해준다. 대신 당연한 이야기지만 선언과 동시에 초기화를 해줘야한다. 뒤에 초기화된 수나 문자를 보고 var가 자동으로 형식을 지정해주기 때문이다.

> var는 지역변수로(메소드 = 함수 안에서만 사용하는 변수)만 사용가능하다. 필드(전역변수 = 멤버변수)는 클래스 필드를 선언할때 명시적 형식을 선언해야한다(int, double등등) 이유는 생성자에서 초기화하는 경우가 많기때문이다

추가 설명을 하면  
![사진](https://user-images.githubusercontent.com/42164422/120899289-ecb3bc80-c669-11eb-8133-f17ed8d32673.png)
에서 보는 거와 같이 var은 컴파일러가 컴파일시점에서 이미 적합한 데이터형식을 파악해서 ex)int a = 20;으로 바꾸기 때문에 CLR은 알길이 없고 int형식의 a=20을 스택에 올린다.

~~~
컴파일타임과 런타임타임을 한번 집고 넘어가자.

소스코드 작성 --> 컴파일러가 변환 -> 기계어코드(그냥 코드일뿐 실행은 안됨) -> CLR이 이 기계어코드를 가지고 실행되는 것을 런타임

컴파일타임은 문법오류(Syntax error)나 파일참조오류 같은것을 미리 잡아줌.
런타임에러은 이미 실행가능한 프로그램으로 컴파일 됫다 할지라도 버그가 있어날수있는데 이를 런타임오류라고함.

결론은 
컴파일은 문법적인 기초적인거 잡아주고 
런타임은 이미실행중일때를 의미함
~~~

## 8. 공용 형식 시스템
C#의 데이터 형식 체계는 CTS표준을 따르고 있다. 생각해보면 c, c++, c#은 데이터형식이 같은 데 이것을 의미한다
참고사진  
![사진](https://t1.daumcdn.net/cfile/blog/1968E1394D7304E418)
int a =123;  
System.Int32 a = 123;  
같은말임.

어떤 변수의 형식을 알고싶고 출력할때는 => a.GetType().ToString() 이라고한다.  
근데 해보니까 a.GetType()만 해도 똑같이 나오기는한다.

## 9. 문자열 다루기 (중요)
들어가기전에 아까 헷갈린것 
클래스에는 속성과 메소드(기능)이 있다. 지금 설명하는 것은 System이라는 네임스페이스에 속해있는 string클래스의 기능(메소드)에 대한 설명이다.
~~~
   메소드  |           설명
 ------------------------------------------------------------
  IndexOf     문자열에서 찾고자하는 문자, 문자열위치를 찾음(첫글자를 0 인덱스로해서)
  ex) string greetring = "Good Morning";
      WriteLine(greeting.IndexOf("Good")); -> 0 이런식 / 없으면 -1반환
--------------------------------------------------------------
LastIndexOf  뒤에서부터찾음/ 뒤에서부터 찾되 찾고나면 인덱스 세는 방식은 앞에서부터
             중복되는것이 있다면 뒤에거부터 우선순위가 주어짐 /없으면 -1반환
----------------------------------------------------------------
StartWith()  지정된 문자열로 시작하는지 체크 -> True, False를 뱉어냄
-----------------------------------------------------------------------
EndsWith()   지정된 문자열로 끝나는지 체크
------------------------------------------------
Contain()    지정된 문자열을 포함하는지 체크 -> True, False를 뱉어냄
------------------------------------------------------------------
Replace()    지정된 문잘이 다른 지정된 문자열로 바꾸고 모든 통 문장을 뱉어냄
ex) greeting.Replace("Morning","Evening); => Good Evening 출력
                      원래문자   바꿀문자
                    
~~~

## 10. 문자열 변형하기(코테할때 많이 쓸듯?)
~~~
   메소드  |           설명
 ------------------------------------------------------------
 ToLower()   모든 대문자를 소문자로
 ------------------------------------------------------------
 ToUpper()   모든 소문자를 대문자로
 ------------------------------------------------------------
 Insert()    지정된 위치에 넣고싶은 문자열을 넣고 통문장 반환
 ex) "Happy Friday!".Insert(5. " Sunny"); => Happy Sunny Friday!
 ------------------------------------------------------------
 Remove()    지정된 위치로부터 지정된수만큼 삭제하고 반환
 ex) "I Don't Love You".Remove(2,6);  => 이거 잘봐야됨 일단 2는 앞에서부터 012하면 D임 D부터
 6개를 없애는데 0부터세아리는게아니라 1부터해서 6개 새아려보면 제일끝 공백까지해서 I Love you가 제거됨
 ------------------------------------------------------------
  Trim()    현재 문자열의 앞뒤 공백을 없에고 반환
 ------------------------------------------------------------
  TrimStart() 앞에 공백만 없애고 반환
  TrimEnd()    뒤에 공백만 없애고 반환
 ~~~

 ## 11. 문자열 분할하기 (많이 씀)
~~~
   메소드     |           설명
 ------------------------------------------------------------
   Sprit()       
  ------------------------------------------------------------
  SubString()   문자열의 지정된 위치로부터 지정된 수만큼 문자로 이루어진 새문자열 반환
  ex) string greeting = "Good Mornig";
       WriteLine(greeting.Substring(5)); => 인덱스 5의 위치는 공백이다 그거 초과로 M부터 반환
                                             ㄴ> Morning
      WriteLine(greeting.SubString(0,5)) => 인덱스 0부터 5미만(공백앞까지) 추출 => Good

~~~
## 12. 문자열 서식 맞추기 (보류)
1.  Format() 메소트
    1.  왼쪽오른쪽 맞춤기능
    2.  숫자 서식화
    3.  날짜 및 시간 서식화
2.  문자열 보간
    1.  $ 들어가있는거는 다 문자열 보간임
